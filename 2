use std::{
    collections::HashMap,
    num::{ParseIntError, TryFromIntError},
};

use crate::op::Op;

pub enum Statement {
    Op(Op),
}

#[derive(Debug, Clone)]
pub enum AssembleErrorKind<'src> {
    MissingDelimiter,
    UnknownOperation,
    UnableToParseInt(ParseIntError),
    IntSize(TryFromIntError),
    MissingArgument,
    TooManyArguments,
    UnknownLabel(&'src str),
    UnexpectedRegisterId(i32),
    UnexpectedImmArgSize,
}

impl From<ParseIntError> for AssembleErrorKind<'_> {
    fn from(value: ParseIntError) -> Self {
        AssembleErrorKind::UnableToParseInt(value)
    }
}

impl From<TryFromIntError> for AssembleErrorKind<'_> {
    fn from(value: TryFromIntError) -> Self {
        AssembleErrorKind::IntSize(value)
    }
}

#[derive(Debug, Clone)]
pub struct AssembleError<'src> {
    kind: AssembleErrorKind<'src>,
    line: usize,
}
impl<'src> AssembleError<'src> {
    pub fn new(state: &ParseState, kind: AssembleErrorKind<'src>) -> Self {
        AssembleError {
            kind,
            line: state.line,
        }
    }
}
const STATEMENT_SEP: char = ';';

pub struct ParseOutput<'src, T> {
    word: T,
    rest: Option<&'src str>,
}

pub struct Label<'src> {
    pub name: &'src str,
    pub position: usize,
}

pub struct ParseState<'src> {
    ops: Vec<Op>,
    op_size_bytes: usize,
    line: usize,
    labels: HashMap<&'src str, usize>,
}
impl<'src> ParseState<'src> {
    pub fn as_bytecode(&self) -> Box<[u8]> {
        let header: [u8; _] = [b'm', b'a'];
        let buffer_size = self.op_size_bytes + size_of_val(&header) + (size_of::<u32>() * 2);
        
        let mut buffer = Vec::with_capacity(buffer_size);  

        buffer.extend_from_slice(&header);
        buffer.extend_from_slice(&(self.op_size_bytes as u32).to_le_bytes());
        buffer.extend_from_slice(&(self.ops.len() as u32).to_le_bytes());

        self.ops.iter().for_each(|o| encode_op(o, &mut buffer));

        buffer.into_boxed_slice()
        
    }
}

impl<'src> ParseState<'src> {
    pub fn new() -> Self {
        ParseState {
            line: 0,
            op_size_bytes: 0,
            labels: HashMap::new(),
            ops: Vec::new(),
        }
    }
}
pub fn slice_until<'src>(
    state: &ParseState,
    rest: &'src str,
    delim: char,
) -> Result<ParseOutput<'src, &'src str>, AssembleError<'src>> {
    let end = rest
        .char_indices()
        .find(|(_, s)| *s == delim)
        .ok_or(AssembleError::new(
            state,
            AssembleErrorKind::MissingDelimiter,
        ))?
        .0;

    let next_rest = rest.get((end + 1)..);
    Ok(ParseOutput {
        word: &rest[..end],
        rest: next_rest,
    })
}

pub fn skip_whitespace<'src>(state: &mut ParseState, rest: &'src str) -> Option<&'src str> {
    for (i, c) in rest.char_indices() {
        match c {
            '\r' | ' ' => {}
            '\n' => state.line += 1,
            _ => return Some(&rest[i..]),
        }
    }
    None
}

pub fn iter_op_args(str: &str) -> impl Iterator<Item = &str> {
    str.split_whitespace()
}

macro_rules! impl_parse_num {
    ($fn_name: ident, $type: ty) => {
        pub fn $fn_name<'src>(
            state: &ParseState,
            str: &'src str,
        ) -> Result<$type, AssembleError<'src>> {
            if str.len() == 1 {
                Ok(<$type>::from_str_radix(str, 10)
                    .map_err(|e| AssembleError::new(state, e.into()))?)
            } else {
                match &str[0..2] {
                    "0x" => Ok(<$type>::from_str_radix(&str[2..], 16)
                        .map_err(|e| AssembleError::new(state, e.into()))?),
                    "0b" => Ok(<$type>::from_str_radix(&str[2..], 2)
                        .map_err(|e| AssembleError::new(state, e.into()))?),
                    _ => Ok(<$type>::from_str_radix(str, 10)
                        .map_err(|e| AssembleError::new(state, e.into()))?),
                }
            }
        }
    };
}
impl_parse_num!(parse_u32, u32);
impl_parse_num!(parse_i32, i32);
impl_parse_num!(parse_u8, u8);

pub enum ArgType<'src> {
    AbsLabelRef(Label<'src>),
    OffLabelRef(Label<'src>),
    Number(i32),
}
impl<'src> ArgType<'src> {
    pub fn get_numeric(&self, state: &ParseState<'src>) -> i32 {
        match self {
            ArgType::AbsLabelRef(label) => label.position as i32,
            ArgType::OffLabelRef(label) => {
                ((state.ops.len() as isize) - (label.position as isize)) as i32
            }
            ArgType::Number(num) => *num,
        }
    }
}
pub fn parse_arg<'src>(
    state: &ParseState<'src>,
    s: &'src str,
) -> Result<ArgType<'src>, AssembleError<'src>> {
    match s.chars().next().unwrap() {
        '@' => {
            let name = &s[1..];
            let position = *state.labels.get(name).ok_or(AssembleError::new(
                state,
                AssembleErrorKind::UnknownLabel(name),
            ))?;

            Ok(ArgType::AbsLabelRef(Label { name, position }))
        }
        '.' => {
            let name = &s[1..];
            let position = *state.labels.get(name).ok_or(AssembleError::new(
                state,
                AssembleErrorKind::UnknownLabel(name),
            ))?;

            Ok(ArgType::OffLabelRef(Label { name, position }))
        }
        _ => {
            let num = parse_i32(state, s)?;
            Ok(ArgType::Number(num))
        }
    }
}

pub fn arg_register<'src>(
    state: &ParseState<'src>,
    args: &mut impl Iterator<Item = &'src str>,
) -> Result<u8, AssembleError<'src>> {
    let s = args.next().ok_or(AssembleError::new(
        state,
        AssembleErrorKind::MissingArgument,
    ))?;
    match parse_arg(state, s)? {
        ArgType::Number(num) => match num {
            0..255 => Ok(num as u8),
            num => Err(AssembleError::new(
                state,
                AssembleErrorKind::UnexpectedRegisterId(num),
            )),
        },
        _ => Err(AssembleError::new(
            state,
            AssembleErrorKind::UnexpectedImmArgSize,
        )),
    }
}

pub fn arg_const<'src>(
    state: &ParseState<'src>,
    args: &mut impl Iterator<Item = &'src str>,
) -> Result<i32, AssembleError<'src>> {
    let s = args.next().ok_or(AssembleError::new(
        state,
        AssembleErrorKind::MissingArgument,
    ))?;
    Ok(parse_arg(state, s)?.get_numeric(state))
}

pub fn parse_op<'src>(
    state: &ParseState<'src>,
    s: &'src str,
) -> Result<(Op, Option<&'src str>), AssembleError<'src>> {
    let statement = slice_until(state, s, ';')?;
    let mut op_str = iter_op_args(statement.word);
    let op_name = op_str.next().unwrap();
    println!("name: {}", op_name);
    let op = match op_name {
        "nop" => Ok(Op::Nop),
        "unreachable" => Ok(Op::Unreachable),
        "drop" => Ok(Op::Drop),
        "const" => Ok(Op::Const(arg_const(state, &mut op_str)?)),
        "jmp" => Ok(Op::Jmp),
        "jmp_if" => Ok(Op::JmpIf),
        "branch" => Ok(Op::Branch),
        "branch_if" => Ok(Op::BranchIf),
        "local_get" => Ok(Op::LocalGet(arg_register(state, &mut op_str)?)),
        "local_set" => Ok(Op::LocalSet(arg_register(state, &mut op_str)?)),
        "local_tee" => Ok(Op::LocalTee(arg_register(state, &mut op_str)?)),
        "global_get" => Ok(Op::GlobalGet(arg_register(state, &mut op_str)?)),
        "global_set" => Ok(Op::GlobalSet(arg_register(state, &mut op_str)?)),
        "global_tee" => Ok(Op::GlobalTee(arg_register(state, &mut op_str)?)),
        "eq" => Ok(Op::Eq),
        "eqz" => Ok(Op::Eqz),
        "add" => Ok(Op::Add),
        "sub" => Ok(Op::Sub),
        "div_s" => Ok(Op::Divs),
        "div_u" => Ok(Op::Divu),
        "mul" => Ok(Op::Mul),
        "neg" => Ok(Op::Neg),
        "gt" => Ok(Op::Gt),
        "lt" => Ok(Op::Lt),
        "ge" => Ok(Op::Ge),
        "le" => Ok(Op::Le),
        "shiftr" => Ok(Op::Shiftr),
        "shiftl" => Ok(Op::Shiftl),
        "call" => Ok(Op::Call),
        "return" => Ok(Op::Return),
        "store_8" => Ok(Op::Store8(arg_const(state, &mut op_str)? as u32)),
        "store_16" => Ok(Op::Store16(arg_const(state, &mut op_str)? as u32)),
        "store_32" => Ok(Op::Store32(arg_const(state, &mut op_str)? as u32)),
        "load_8_u" => Ok(Op::Load8u(arg_const(state, &mut op_str)? as u32)),
        "load_8_s" => Ok(Op::Load8s(arg_const(state, &mut op_str)? as u32)),
        "load_16_s" => Ok(Op::Load16s(arg_const(state, &mut op_str)? as u32)),
        "load_16_u" => Ok(Op::Load16u(arg_const(state, &mut op_str)? as u32)),
        "load_32_s" => Ok(Op::Load32s(arg_const(state, &mut op_str)? as u32)),
        "load_32_u" => Ok(Op::Load32u(arg_const(state, &mut op_str)? as u32)),
        "extend_8_32_s" => Ok(Op::Extend8_32s),
        "extend_16_32_s" => Ok(Op::Extend16_32s),
        "extend_8_32_u" => Ok(Op::Extend8_32u),
        "extend_16_32_u" => Ok(Op::Extend16_32u),
        _ => Err(AssembleError::new(
            state,
            AssembleErrorKind::UnknownOperation,
        )),
    }?;
    match op_str.next() {
        Some(_) => Err(AssembleError::new(
            state,
            AssembleErrorKind::TooManyArguments,
        )),
        None => Ok((op, statement.rest)),
    }
}

pub fn parse_label<'src>(
    state: &ParseState,
    s: &'src str,
) -> Result<(Label<'src>, Option<&'src str>), AssembleError<'src>> {
    let label = slice_until(state, s, ':')?;
    let position = state.ops.len();
    println!("rest: {:?}", label.rest);
    Ok((
        Label {
            name: label.word,
            position,
        },
        label.rest,
    ))
}

pub fn parse<'src>(code: &'src str) -> Result<ParseState<'src>, AssembleError<'src>> {
    let mut rest = Some(code);
    let mut state = ParseState::new();
    loop {
        match rest {
            Some(r) => match r.chars().next() {
                Some('\n') | Some('\r') | Some(' ') => rest = skip_whitespace(&mut state, r),
                Some(':') => {
                    let label = parse_label(&state, &r[1..])?;
                    state.labels.insert(label.0.name, label.0.position);
                    rest = label.1;
                }
                Some('#') => {
                    let statement = slice_until(&state, &r[1..], ';')?;
                    println!("{:?}", statement.rest);
                    let arg = parse_arg(&state, statement.word)?; 
                    state.ops.push(Op::Const(arg.get_numeric(&state)));
                     
                    rest = statement.rest;
                }
                
                Some(_) => {
                    let op_res = parse_op(&state, r)?;
                    state.op_size_bytes += op_res.0.size_bytes() as usize;
                    state.ops.push(op_res.0);
                    rest = op_res.1;
                }
                None => break,
            },
            None => break,
        }
    }
    Ok(state)
}

pub fn encode_op(op: &Op, buffer: &mut Vec<u8>) {
    buffer.push(op.repr());
    match op {
        Op::Const(num) => {
            buffer.extend_from_slice(&num.to_le_bytes());
        }

        Op::LocalGet(num)
        | Op::LocalSet(num)
        | Op::LocalTee(num)
        | Op::GlobalGet(num)
        | Op::GlobalSet(num)
        | Op::GlobalTee(num) => buffer.push(*num),

        Op::Store8(off)
        | Op::Store16(off)
        | Op::Store32(off)
        | Op::Load8u(off)
        | Op::Load8s(off)
        | Op::Load16s(off)
        | Op::Load16u(off)
        | Op::Load32s(off)
        | Op::Load32u(off) => buffer.extend_from_slice(&off.to_le_bytes()),

        _ => {}
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn parse_number() {
        let s = ParseState::new();

        assert_eq!(parse_i32(&s, "0xFA").unwrap(), 250);
        assert_eq!(parse_i32(&s, "0x-7D0").unwrap(), -2000);
        assert_eq!(parse_i32(&s, "500").unwrap(), 500);
        assert_eq!(parse_i32(&s, "+9876").unwrap(), 9876);
    }

    #[test]
    fn parse_single_op() {
        let s = ParseState::new();
        assert_eq!(parse_op(&s, "nop;").unwrap().0, Op::Nop);
        assert_eq!(parse_op(&s, "local_get 5;").unwrap().0, Op::LocalGet(5));
        assert_eq!(parse_op(&s, "local_set 0xA;").unwrap().0, Op::LocalSet(10));
    }

    #[test]
    fn parse_multiple() {
        let code = "
            nop;


                    local_get 5; local_set 0xA;
            nop;
        ";
        let ops = parse(code).unwrap().ops;

        assert_eq!(ops[0], Op::Nop);
        assert_eq!(ops[1], Op::LocalGet(5));
        assert_eq!(ops[2], Op::LocalSet(10));
    }

    #[test]
    fn parse_with_labels() {
        let code = "
            :blub:
            nop;
            nop;
            nop;

            :label:
            const @label;
            #@blub; #.label;
            #100;
            jmp;     
        ";
        let ops = parse(code).unwrap().ops;
        assert_eq!(ops[3], Op::Const(3));
        assert_eq!(ops[4], Op::Const(0));
        assert_eq!(ops[5], Op::Const(2));
        assert_eq!(ops[6], Op::Const(100));
    }
    
}
